/*
 * Empty C++ Application
 */

#include "xparameters.h"
#include <stdio.h>
#include "lena_dataset.h"

int *dct_test  = (int*)XPAR_DARC_DCT_0_S00_AXI_BASEADDR;
int *DDR3_DATA = (int*)XPAR_PS7_DDR_0_S_AXI_BASEADDR;
int *BRAM =(int*)XPAR_DARC_BRAM_0_S00_AXI_BASEADDR;

int img_dct[64];
short int output[64];
short int output_bram[512*512];

short int bram_read(bool we, int addr)
{
	short int data_out;
	*(BRAM + 2) = addr; // Address from where data needs to be fetched
	*(BRAM + 1) = we;  // when reading we must be set to 0

	for(int i = 1000; i >0; i--){;}
	data_out = *(BRAM+3);
	for(int i = 1000; i >0; i--){;}

	return data_out;
}

void bram_write(bool we, int addr, short int data_in)
{
	*(BRAM + 2) = addr; // Address from where data needs to be fetched
	*(BRAM + 1) = we;  // when writing we must be set to 1
	*(BRAM + 0) = data_in; // Input data to write to memory
	for(int i = 1000; i >0; i--){;}
}

int trigger_dct(int *value, int column_idx, int row_idx)
{

	*(dct_test + 130) = 0x0; // Activate Reset
	for(int i = 10000; i >0; i--)
	{
		;
	}
	*(dct_test + 130) = 0x1; // Reactive Reset and start sending input signals
	for(int i = 10000; i >0; i--)
	{
		;
	}
	// Inputs to DCT Module
	for(int idx = 0; idx <64; idx ++)
	{
		*(dct_test + idx) = *(value + idx);
	}

	while(!(*(dct_test + 129)==1));// Check Valid Signal is active or not

	for(int i = 10000; i >0; i--)
	{
		;
	}

	// Sample the Outputs
	for(int idx =0; idx<64;idx++)
	{
		output[idx]= *(dct_test + 64 + idx);
		//printf("Result SOP[%d]: 0x%x\n", idx,output[idx]);
	}

	//Saving results to bram
	for(int j=0;j<8;j++)
	{
		for(int i=0;i<8;i++)
			{
				output_bram[(j+column_idx*8)+((i+8*row_idx)*512)]=output[i+(j*8)];
				//*(DDR3_DATA + ((j+column_idx*8)+((i+8*row_idx)*512))) = output[j+(i*8)];
				if(column_idx == 63 && row_idx == 63)
				{
					bram_write(1,((j+column_idx*8)+((i+8*row_idx)*512)), output_bram[(j+column_idx*8)+((i+8*row_idx)*512)]);
					printf("Result SOP[%d]: 0x%x\n",((j+column_idx*8)+((i+8*row_idx)*512)),output_bram[(j+column_idx*8)+((i+8*row_idx)*512)]);
				}
			}
	}

	for(int i = 10000; i >0; i--)
	{
		;
	}
	*(dct_test + 130) = 0x0; // Activate Reset

	return 0;
}

int main()
{
/*
	int img_dct[64];

	*(dct_test + 130) = 0x0; // Activate Reset
	for(int i = 10000; i >0; i--)
	{
		;
	}
	*(dct_test + 130) = 0x1; // Reactive Reset and start sending input signals
	for(int i = 10000; i >0; i--)
	{
		;
	}
	//Reading the image
	for(int j=0;j<8;j++)
	{
		for(int i=0;i<8;i++)
		{
			img_dct[j+(i*8)]=img[j+(i*512)];
		}
	}
	// Inputs to DCT Module
	for(int idx = 0; idx <64; idx ++)
	{
		*(dct_test + idx) = img_dct[idx];
	}

	while(!(*(dct_test + 129)==1));// Check Valid Signal is active or not

	for(int i = 10000; i >0; i--)
	{
		;
	}

	int output[64];
	// Sample the Outputs
	for(int idx =0; idx<64;idx++)
	{
		output[idx]= *(dct_test + 64 + idx);
		printf("Result SOP[%d]: %d\n", idx,output[idx]);
	}

	for(int i = 10000; i >0; i--)
	{
		;
	}
	*(dct_test + 130) = 0x0; // Activate Reset

	for(int i = 10000; i >0; i--)
	{
		;
	}

	//trigger_dct(2);
*/
	//Reading the image
	for(int row_idx =0; row_idx <64;row_idx++)
	{
		for(int col_idx =0;col_idx<64; col_idx++)
		{
			for(int j=0;j<8;j++)
				{
					for(int i=0;i<8;i++)
					{
						img_dct[j+(i*8)]=img[(j+col_idx*8)+((i+8*row_idx)*512)];
					}
				}

			for(int i = 10000; i >0; i--){;}

			// Calling DCT Kernel
			trigger_dct(img_dct, col_idx,row_idx);

			for(int i = 10000; i >0; i--){;}


		}
	}

	// Reading BRAM Memory
/*	for(int k =0; k<8; k++)
	{
		short int data_out=bram_read(0,k);
		printf("BRAM_Data[%d]: 0x%x\n", k, data_out);
	}
*/
	int cl_br_rd =63;
	int rw_br_rd =63;
	for(int j=0;j<8;j++)
	{
		for(int i=0;i<8;i++)
			{
				short int data_out=bram_read(0,((j+cl_br_rd*8)+((i+rw_br_rd*8)*512)));
				printf("Result SOP[%d]: 0x%x\n",((j+cl_br_rd*8)+((i+rw_br_rd*63)*512)), data_out);
			}
	}
	return 0;
}
