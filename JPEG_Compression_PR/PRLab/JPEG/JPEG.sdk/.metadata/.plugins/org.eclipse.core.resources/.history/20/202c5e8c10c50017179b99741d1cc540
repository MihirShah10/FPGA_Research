/*
 * Empty C++ Application
 */
#include "xparameters.h"
#include "lena_dataset.h"
//#include "Goldhill.h"
//#include "peppers_dataset.h"
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <bitset>

using namespace std;
#include "xsdps.h"
#include "xil_printf.h"
#include "ff.h"
#include "xil_cache.h"

#include <string.h>

#include "xparameters.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include "ff.h"
#include "xdevcfg.h"
#include "xil_io.h"
#include "xil_types.h"

#include "xbasic_types.h"
#include "xil_exception.h"
#include "xsdps.h"
#include "math.h"
#include "string.h"

int *DDR3_DATA = (int*)XPAR_PS7_DDR_0_S_AXI_BASEADDR;
int *JPEG_PR  = (int*)XPAR_JPEG_PR_0_S00_AXI_BASEADDR;

// Generic variables
int sample_block[64*64][64];
short int dc_value[64*64];

// DCT variables
short int dct_data[64*64][64];

// Quantization variables
short int quantz_data[64*64][64];

// RLE variables
short int rle_data[64*64][128];
short int rle_max_length_buffer[64*64];

// Huffman variables
unsigned int bit_length=0;
int huffman_encoded_out [64*64][16];
unsigned short int huffman_last_bit[64*64];

// Huffman_Binary variables
char buffer[64*64][512];


// PR Parameters Begin
// Parameters for Partial Reconfiguration
#define PARTIAL_DCT_ADDR   			0x4000000
#define PARTIAL_QUANTZ_ADDR   		0x8000000

#define PARTIAL_SOBEL_BITFILE_LEN       0x279F60 // in number of words
#define PARTIAL_GAUSSIAN_BITFILE_LEN    0x279F60 // in number of words

// SLCR registers
#define SLCR_LOCK				0xF8000004 // SLCR Write Protection Lock
#define SLCR_UNLOCK				0xF8000008 // SLCR Write Protection Unlock
#define SLCR_LVL_SHFTR_EN 		0xF8000900 // SLCR Level Shifters Enable
#define SLCR_PCAP_CLK_CTRL XPAR_PS7_SLCR_0_S_AXI_BASEADDR + 0x168 // SLCR PCAP clock control register address

#define SLCR_PCAP_CLK_CTRL_EN_MASK 	0x1
#define SLCR_LOCK_VAL				0x767B
#define SLCR_UNLOCK_VAL				0xDF0D

#define NUMOFCHARS 8


// Turn on/off Debug messages
#ifdef DEBUG_PRINT
#define  debug_printf  xil_printf
#else
#define  debug_printf(msg, args...) do {  } while (0)
#endif

// Read function for STDIN
extern char inbyte(void);

static int Reset = 1;
static FATFS fatfs;

// Driver Instantiations
static XDcfg_Config *XDcfg_0;
XDcfg DcfgInstance;
XDcfg *DcfgInstPtr;

int itoa(int n, char s[], int NumOfChars);// Parameter Definitions


// PR Parameters End

int trigger_dct(int column_idx, int row_idx)
{

	*(JPEG_PR + 130) = 0x0; // Activate Reset
	for(int i = 1000; i >0; i--){;} // 10k original, 1000 gives 13 us delay

	// Inputs to DCT Module
	for(int idx = 0; idx <64; idx ++)
	{
		*(JPEG_PR + idx) = sample_block[column_idx + (row_idx*64)][idx];
	}

	*(JPEG_PR + 130) = 0x1; // Reactive Reset and start sending input signals
	for(int i = 1000; i >0; i--){;} // 10k original, 1000 gives 13 us delay

	while(!(*(JPEG_PR + 129)==1));// Check Valid Signal is active or not

	for(int i = 1000; i >0; i--){;} // 10k original, 1000 gives 13 us delay

	// Sample the Outputs
	//printf("DCT_Data[%d]: ",column_idx + (row_idx*64));
	for(int idx =0; idx<64;idx++)
	{
		dct_data[column_idx + (row_idx*64)][idx]= *(JPEG_PR + 64 + idx);
		//printf("0x%x,",dct_data[column_idx + (row_idx*64)][idx]);
	}
	//printf("\n");

	// Saving the DC Value
	dc_value[column_idx + (row_idx*64)]=dct_data[column_idx + (row_idx*64)][0];

	*(JPEG_PR + 130) = 0x0; // Activate Reset
	for(int i = 1000; i >0; i--){;} //10k original, 1000 gives 13 us delay

	return 0;
}

int trigger_quantz(int column_idx, int row_idx)
{
	// Reset to Active Low
	for(int i =100; i<0;i--){;} // Wait for 2 us
	*(JPEG_PR + 130)= 0x0;

	for(int i=100; i<0;i--){;} // Wait for 2 us
	for(int j=0; j<8; j++)
	{
		for(int i=0;i<8;i++)
		{
			*(JPEG_PR + (8*j+i))=  dct_data[column_idx + (row_idx*64)][i*8+j];
		}
	}

	for(int i =100; i<0;i--){;} // Wait for 2 us
	*(JPEG_PR + 130)= 0x1; // Reset High to Start the Processing

	while(!(*(JPEG_PR + 129)==1)); // Wait for valid signal to be high

	for(int i =100; i<0;i--){;} // Wait for 2 us

	// Sample the Outputs
	//printf("Quantz_Data[%d]: ",column_idx + (row_idx*64));
	for(int idx =0; idx<64;idx++)
	{
		quantz_data[column_idx + (row_idx*64)][idx]= *(JPEG_PR + 64 + idx);
		//printf("0x%x,",quantz_data[column_idx + (row_idx*64)][idx]);
	}
	//printf("\n");
	// Saving the DC value
	dc_value[column_idx + (row_idx*64)] = quantz_data[column_idx + (row_idx*64)][0];

	*(JPEG_PR + 130)= 0x0;
	for(int i =100; i<0;i--){;} // Wait for 2 us

	return 0;
}

int dct_compute()
{
	// DCT Computation
		for(int row_idx =0; row_idx <64;row_idx++)
		{
			for(int col_idx =0;col_idx<64; col_idx++)
			{
				for(int j=0;j<8;j++)
				{
					for(int i=0;i<8;i++)
					{
						sample_block[col_idx + (row_idx*64)][j+(i*8)]=img[(j+col_idx*8)+((i+8*row_idx)*512)];
					}
				}
				for(int i = 100; i >0; i--){;}       // original 10k however, 100 gives 2us delay
				trigger_dct(col_idx,row_idx); 	     // Calling DCT Kernel
				for(int i = 100; i >0; i--){;}       // original 10k however, 100 gives 2us delay
			}
		}


	return 0;
}

int quantization_compute()
{
	// Quantization Computation
		for(int row_idx =0; row_idx <64;row_idx++)
		{
			for(int col_idx =0;col_idx<64; col_idx++)
			{
				for(int i = 100; i >0; i--){;}       // original 10k however, 100 gives 2us delay
				trigger_quantz(col_idx,row_idx); 	     // Calling Q Kernel
				for(int i = 100; i >0; i--){;}       // original 10k however, 100 gives 2us delay
			}
		}

	return 0;
}
int main()
{


	return 0;
}
